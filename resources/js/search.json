[[{"i":"welcome","l":"Welcome!","p":["Welcome to the WORK IN PROGRESS beginners' guide to using Kotlin in your FTC codebase!","This guide assumes that you know how to program in Kotlin, but no other FTC programming knowledge is necessary. This guide is meant for absolute beginners who do not have any experience with programming for FTC.","This is intended as a foundational guide for beginning programmers who may not be comfortable with translating code from Java to Kotlin yet. I started this project because there weren't any guides for me when I first started to program. While I was able to get by using old code, rookie teams without any reference would struggle without it. Kotlin is simply the easier programming language to use, and the goal of K4FTC is to make this an option for first-timers."]},{"l":"Contributing","p":["To contribute, all you have to do is make a pull request to the main branch with the changes you would like to make. This is greatly appreciated as this is currently a solo, volunteer project."]},{"l":"Contributors","p":["This is a list of people who have made significant contributions to K4FTC. Feel free to add yourself to this list as a part of your PR in the format shown below.","Avery L., FTC 11468"]},{"l":"Running locally","p":["To run this website locally, first install Retype. This can be accomplished by running the following command, assuming you already have NodeJS installed:","After navigating to the directory where you cloned the repository, run the following command to open the website in your web browser:"]}],[{"l":"Prerequisites","p":["Before you begin programming, there are a few tasks that need to be completed to ensure your hardware is ready."]},{"l":"Hardware Setup","p":["Assuming you are using a REV Control Hub, REV has graciously provided a guide on configuring it. It is recommended to read through \"Next Steps\" as we will be going into more detail about some of the things that are mentioned.","FIRST has also provided a guide for making a configuration file for your robot, as well as physically connecting hardware. Please note that FIRST's choice of hardware in this tutorial does not necessarily reflect best practices and modern preferences for certain devices, and that due diligence should be done in choosing devices."]},{"l":"Software Setup","p":["Before proceeding with this guide, please make sure you have done the following:","Have the latest version of Android Studio downloaded and installed.","Have a repository containing the latest version of the FTC SDK. I would recommend forking this on Github first and then cloning the fork locally.","Make sure the Kotlin Plugin is downloaded in Android Studio."]}],[{"l":"Installation","p":["Installing Kotlin into your FTC project is very easy and shouldn't take more than a few minutes."]},{"l":"Project Gradle Script","p":["The first step of adding Kotlin to your FTC project is by adding Kotlin to the build.gradle file that has Project: REPO-NAME next to it. Add the indicated lines of code to the aforementioned file:"]},{"l":"TeamCode Gradle Script","p":["The only other thing you have to do is copy the indicated line of code into the build.gradle file that has Module: TeamCode next to it.","If you are confused on where to copy the code, I have labeled the place to copy the first set of lines in blue, and the other line in yellow. Please ignore everything else, as this is a preexisting project that has other libraries installed. After doing this, you should be ready to start programming!"]}],[{"i":"what-is-an-opmode","l":"What is an OpMode?","p":["An OpMode is a class that you create that is runnable on your robot.","There are two types of classes that can be extended to make an OpMode: LinearOpMode and OpMode. Both will be explained in this guide, but LinearOpMode will be used for any further examples for simplicity sake.","The general rule is that code in a regular OpMode is divided up based on the conditions where it will be executed, while code in a LinearOpMode runs consecutively using methods to pause execution."]},{"l":"LinearOpMode","p":["Here are the most important methods included in the LinearOpMode class. Certain methods have been excluded because they aren't needed for amateur programmers, but you can find all of them in FIRST's documentation.","runOpMode( ) All code within this method will run once when the OpMode is initialized on your Driver Station.","waitForStart() This method will pause execution of code until you press the \"Start\" button on your driver station. This would be used if you wanted to run code in between initializing the code and the start of the period during a match.","isStarted() This method will return true if the \"Start\" button has been pressed.","isStopRequested() This method will return true if the \"Stop\" button was pressed.","opModeIsActive() will return isStarted() !isStopRequested()","opModeInInit() will return !isStarted() !isStopRequested()","Here is an example LinearOpMode that uses some of these methods:"]},{"l":"OpMode","p":["Here are all of the methods included in the OpMode class. Note that the first two are mandatory and you will get an error if you don't override both of them.","init() The code within this method will run once when the \"Init\" button is pressed","loop() The code within this method will run continuously when you press \"Start\" and until you press \"Stop\"","start() The code within this method will run once when you press the \"Start\" button. This will always run before the code in the loop() method.","init_loop The code within this method will run continously when you press the \"Init\" button. This will always run after the code in the init() method.","stop() The code within this method will run once when you press the \"Stop\" button. You should not have any code that controls the drivetrain in this method because you may be penalized in competition for moving after the match is over.","Here is an example OpMode."]},{"i":"warning-regarding-while-loops","l":"Warning regarding while() loops","p":["Only use a while() loop if you have some sort of exit condition. Otherwise, it will take an additional 5 seconds to stop the robot when you press the \"Stop\" button. This will cause you to incur penalties during autonomous if it keeps running after the 30 second period. Your code should be programmed in a way to be responsive to stop requests. One way of doing this in a LinearOpMode is adding opModeIsActive() as a condition for the loop, as the loop will know to exit after you press stop."]},{"i":"opmode-1","l":"OpMode","p":["Here are all of the methods included in the OpMode class. Note that the first two are mandatory and you will get an error if you don't override both of them.","init() The code within this method will run once when the \"Init\" button is pressed","loop() The code within this method will run continuously when you press \"Start\" and until you press \"Stop\"","start() The code within this method will run once when you press the \"Start\" button. This will always run before the code in the loop() method.","init_loop The code within this method will run continously when you press the \"Init\" button. This will always run after the code in the init() method.","stop() The code within this method will run once when you press the \"Stop\" button. You should not have any code that controls the drivetrain in this method because you may be penalized in competition for moving after the match is over.","Here is an example OpMode."]}],[{"l":"hardwareMap"},{"i":"what-is-a-hardwaremap","l":"What is a hardwareMap?","p":["A hardwareMap is a class in the FTC SDK that, using its get method, takes a class for a specific device and its name in the configuration file you made using your REV Driver Hub. It then returns an object for the device you inputted and allows for you to control it in code."]},{"i":"what-would-you-use-it-for","l":"What would you use it for?","p":["The hardwareMap class is used to initializing every component of your robot into your code so you can control each of them. For example, for a DcMotor assigned to the variable frontLeftMotor, you would turn it on full power using frontLeftMotor.power = 1.0. Note how power for motors is stored as a Double. Overall, the hardwareMap class is vital to programming and it will be used extensively throughout your entire FTC programming career."]}],[{"l":"Motors","p":["In FTC, there are 2 classes that are used to control your motors: DcMotor and DcMotorEx. These 2 classes are very similar, and if you don't plan on using the encoders attached to your motors, either of them will work.","However, if you do intend to use the encoders on your motors for features such as measuring velocity or error correction, using the DcMotorEx class is required. That being said, if you are using Mecanum wheels and want to know where your robot is on the field during autonomous, I would invest in external encoders in the form of dead wheels due to how Mecanum wheels can slip."]},{"l":"Encoders","p":["Encoders are the devices built into your motors that track how many times that they have rotated in terms of \"ticks\", where each encoder has a designated amount ticks per rotation that can be found on the manufacturer's website.","There are two types of encoders: absolute and relative. Absolute encoders give you the angle that the shaft has rotated in starting from the starting point. In a world where these encoders gave you measurements in degrees, they would give you a number between 0 and 360. A relative encoder, on the other hand, gives the amount of times it has rotated forward since being reset, which would give you an answer from -∞ to +∞. You can get the position of the encoder in code by calling the method getCurrentPosition on a DcMotor object.","The encoders on any motor that you would use in FTC today are relative and keep the number of ticks recorded until you reset them in code or restart the Robot Controller."]},{"l":"Direction","p":["As you might expect, there are two possible directions that a motor can be set to go in, with those being FORWARD and BACKWARD. You can set a motor to run in these directions by running the following:","motor.setDirection(DcMotor.Direction.FORWARD)","motor.setDirection(DcMotor.Direction.BACKWARD)","By default, the direction is set to FORWARD. exampleMotor.power = 1.0 will run the motor forwards by default, and backwards under BACKWARD mode. The opposite is true for exampleMotor.power = -1.0."]},{"l":"Run Modes","p":["Run modes determine how your motor will react to the input that you give it, which is usually the power variable. To change the run mode of a motor, use the method motor.setMode(DcMotor.RunMode.RUN_MODE)"]},{"l":"RUN_WITHOUT_ENCODERS","p":["RUN_WITHOUT_ENCODERS is by far the simplest way of running a motor. The motor will be provided with the amount of electricity specified in the power variable, with 1.0 being the maximum amount of electricity going in the direction specified, and 0.0 resulting in no power delivered to the motor"]},{"l":"RUN_WITH_ENCODERS","p":["RUN_WITH_ENCODERS uses the motor's built in encoder (assuming you plugged it in) to run the motor to the specified speed specified in the power variable, with 1.0 being full speed ahead and 0 being idle. While one might think that this is the same as the previously specified run mode, this is incorrect. Under the previous mode, you can run the motor at 0.5 electricity while the motor itself runs 10% faster or slower. However, running the motor on this mode will always result in the motor running at the specified speed because the encoder reads how fast the motor is turning and adjusts the amount of electricity provided."]},{"l":"RUN_TO_POSITION","p":["In order to use the RUN_TO_POSITION run mode, you have to make sure you have already set a position for the motor to go to. Simply set the value of the variable targetPosition to the amount of encoder ticks you want it to travel, and the motor will run to that position when you change the run mode."]},{"l":"Note","p":["RUN_TO_POSITION should only be used in single motor mechanisms such as a claw because multiple motor mechanisms are significantly harder to control with this mode in comparison to others."]},{"l":"STOP_AND_RESET_ENCODER","p":["STOP_AND_RESET_ENCODER will force the motor to come to a complete stop and reset the number of ticks that the encoders have recorded. After that, you have to chose another run mode to set the motor to."]},{"l":"Zero Power Behaviors","p":["Zero power behaviors effect how your motors come to a stop when power is not applied.","There are two different zero power behaviors available in the FTC SDK, with those being brake and float.","BRAKE will slow your motor down by applying force in the opposite direction.","FLOAT will let your motors slow down using friction alone.","To change your zero power behavior, use the method motor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BEHAVIOR_NAME)."]},{"l":"DcMotorEx addendum","p":["For people wanting to use certain encoder features, you should instantiate your motors using the DcMotorEx class. This gives you a few more extra features."]},{"l":"Velocity","p":["The DcMotorEx class allows you to set your motor to a certain velocity in terms of encoder ticks. To do such, set the value of the velocity variable of the DcMotorEx object to the amount of ticks per second you want it to run at."]}],[{"l":"Servos","p":["The FTC SDK provides 2 classes for servos: Servo and CRServo (continuous rotation servo). These refer to different device types in configuration, so make sure the class you use reflects the device type you set in configuration. Most servos lack a continuous rotation mode, so ensure you use a compatible servo for mechanisms requiring continuous rotation."]},{"l":"Servo Class","p":["The servo class only has one variable that you will use frequently in programming."]},{"l":"Position","p":["Servo.position refers to the current position of the servo, with 0.0 being fully retracted and 1.0 being fully extended. If you use a servo programmer to change where the servo starts and stops, 0.0 will be the retracted state you set, and 1.0 will be the extended state you set. For example:","will move the servo to its retracted state, exactly halfway between retracted and extended, and finally all the way to extended."]},{"l":"CRServo","p":["CRServo has two methods that you will use. These are very similar to the methods of DcMotor."]},{"l":"Power","p":["CRServos are controlled by setting their power exactly like a DcMotor. Please refer to that section again if necessary."]},{"l":"Direction","p":["For direction, CRServos are controlled exactly the same as a DcMotor, using the enumerated class DcMotorSimple.Direction. Please refer to that section again if necessary."]}]]